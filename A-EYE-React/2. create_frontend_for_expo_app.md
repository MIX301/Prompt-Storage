# Create frontend for Expo app
_Exported on 15/11/2025 at 4:55:21 CET from Cursor (1.7.44)_

---

**User**

I have created a started expo app in @A-eye/ Create the frontend around this flask backend we have in the root folder.

---

**Cursor**


Reviewing the Flask backend and the Expo app structure to understand the API and current setup.



Reviewing the Expo app structure:



Creating the frontend for the Flask backend. Planning and implementing step by step:



Installing socket.io-client and creating the frontend:



Creating the Socket.IO context and main AI assistant screen:


```typescriptreact
import React, { createContext, useContext, useEffect, useState, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

type SessionMode = 'camera' | 'screen' | 'none';

interface SocketContextType {
  socket: Socket | null;
  connected: boolean;
  sessionActive: boolean;
  currentMode: SessionMode;
  responseText: string;
  statusMessage: string;
  statusType: 'connected' | 'disconnected' | 'info' | 'error';
  startSession: (mode: SessionMode) => void;
  stopSession: () => void;
  sendMessage: (text: string) => void;
  setCurrentMode: (mode: SessionMode) => void;
}

const SocketContext = createContext<SocketContextType | undefined>(undefined);

// Default backend URL - can be overridden with environment variable
const BACKEND_URL = process.env.EXPO_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export function SocketProvider({ children }: { children: React.ReactNode }) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [connected, setConnected] = useState(false);
  const [sessionActive, setSessionActive] = useState(false);
  const [currentMode, setCurrentMode] = useState<SessionMode>('camera');
  const [responseText, setResponseText] = useState('');
  const [statusMessage, setStatusMessage] = useState('Disconnected');
  const [statusType, setStatusType] = useState<'connected' | 'disconnected' | 'info' | 'error'>('disconnected');

  useEffect(() => {
    // Initialize socket connection
    const newSocket = io(BACKEND_URL, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
    });

    // Connection events
    newSocket.on('connect', () => {
      setConnected(true);
      setStatusMessage('Connected to server');
      setStatusType('connected');
    });

    newSocket.on('disconnect', () => {
      setConnected(false);
      setSessionActive(false);
      setStatusMessage('Disconnected from server');
      setStatusType('disconnected');
    });

    newSocket.on('connected', (data: { status: string }) => {
      setStatusMessage(`Connected: ${data.status}`);
      setStatusType('connected');
    });

    // Session events
    newSocket.on('session_started', (data: { status: string; mode: SessionMode }) => {
      setSessionActive(true);
      setStatusMessage(`Session started in ${data.mode} mode`);
      setStatusType('info');
    });

    newSocket.on('session_stopped', (data: { status: string }) => {
      setSessionActive(false);
      setStatusMessage('Session stopped');
      setStatusType('disconnected');
      setResponseText('');
    });

    // Response events
    newSocket.on('text_response', (data: { text: string }) => {
      setResponseText((prev) => prev + data.text);
    });

    newSocket.on('audio_data', (data: { data: string }) => {
      // Audio data handling can be added here if needed
      console.log('Audio data received');
    });

    newSocket.on('info', (data: { message: string }) => {
      setStatusMessage(`Info: ${data.message}`);
      setStatusType('info');
    });

    newSocket.on('error', (data: { message: string }) => {
      const msg = data.message || '';
      // Don't show alerts for disabled features, just update status
      if (
        msg.includes('not available') ||
        msg.includes('disabled') ||
        msg.includes('PyAudio') ||
        msg.includes('Audio output') ||
        msg.includes('Audio input') ||
        msg.includes('Camera') ||
        msg.includes('Text-only')
      ) {
        setStatusMessage(`Info: ${msg}`);
        setStatusType('info');
      } else {
        setStatusMessage(`Error: ${msg}`);
        setStatusType('error');
      }
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, []);

  const startSession = (mode: SessionMode) => {
    if (socket && connected) {
      socket.emit('start_session', { mode });
      setCurrentMode(mode);
    }
  };

  const stopSession = () => {
    if (socket && sessionActive) {
      socket.emit('stop_session');
      setResponseText('');
    }
  };

  const sendMessage = (text: string) => {
    if (socket && sessionActive && text.trim()) {
      socket.emit('send_message', { text: text.trim() });
    }
  };

  return (
    <SocketContext.Provider
      value={{
        socket,
        connected,
        sessionActive,
        currentMode,
        responseText,
        statusMessage,
        statusType,
        startSession,
        stopSession,
        sendMessage,
        setCurrentMode,
      }}>
      {children}
    </SocketContext.Provider>
  );
}

export function useSocket() {
  const context = useContext(SocketContext);
  if (context === undefined) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}

```


Updating the root layout to include the SocketProvider and creating the main AI assistant screen:



Updating the root layout to include the SocketProvider and creating the main AI assistant screen:


```typescriptreact
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/use-color-scheme';
import { SocketProvider } from '@/contexts/SocketContext';

export const unstable_settings = {
  anchor: '(tabs)',
};

export default function RootLayout() {
  const colorScheme = useColorScheme();

  return (
    <SocketProvider>
      <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
        <Stack>
          <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
          <Stack.Screen name="modal" options={{ presentation: 'modal', title: 'Modal' }} />
        </Stack>
        <StatusBar style="auto" />
      </ThemeProvider>
    </SocketProvider>
  );
}

```

```typescriptreact
import React, { useState } from 'react';
import {
  StyleSheet,
  View,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Platform,
  Alert,
} from 'react-native';
import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { useSocket } from '@/contexts/SocketContext';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

type SessionMode = 'camera' | 'screen' | 'none';

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const {
    connected,
    sessionActive,
    currentMode,
    responseText,
    statusMessage,
    statusType,
    startSession,
    stopSession,
    sendMessage,
    setCurrentMode,
  } = useSocket();

  const [messageInput, setMessageInput] = useState('');

  const handleStartSession = () => {
    if (!connected) {
      Alert.alert('Not Connected', 'Please wait for connection to server');
      return;
    }
    startSession(currentMode);
  };

  const handleStopSession = () => {
    stopSession();
    setMessageInput('');
  };

  const handleSendMessage = () => {
    if (messageInput.trim()) {
      sendMessage(messageInput);
      setMessageInput('');
    }
  };

  const getStatusColor = () => {
    switch (statusType) {
      case 'connected':
        return '#10b981';
      case 'disconnected':
        return '#ef4444';
      case 'info':
        return '#3b82f6';
      case 'error':
        return '#ef4444';
      default:
        return '#6b7280';
    }
  };

  const modeButtons: { mode: SessionMode; label: string; icon: string }[] = [
    { mode: 'camera', label: 'Camera', icon: 'üì∑' },
    { mode: 'screen', label: 'Screen', icon: 'üñ•Ô∏è' },
    { mode: 'none', label: 'None', icon: 'üö´' },
  ];

  const colors = Colors[colorScheme ?? 'light'];

  return (
    <ThemedView style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}>
        {/* Header */}
        <ThemedView style={styles.header}>
          <ThemedText type="title" style={styles.title}>
            üéôÔ∏è Gemini Live API
          </ThemedText>
          <ThemedText style={styles.subtitle}>
            Real-time audio and video interaction
          </ThemedText>
        </ThemedView>

        {/* Status */}
        <ThemedView
          style={[
            styles.statusContainer,
            { backgroundColor: getStatusColor() + '20', borderColor: getStatusColor() },
          ]}>
          <ThemedText style={[styles.statusText, { color: getStatusColor() }]}>
            {statusMessage}
          </ThemedText>
        </ThemedView>

        {/* Mode Selection */}
        <ThemedView style={styles.section}>
          <ThemedText type="subtitle" style={styles.sectionTitle}>
            Video Mode
          </ThemedText>
          <View style={styles.modeContainer}>
            {modeButtons.map(({ mode, label, icon }) => (
              <TouchableOpacity
                key={mode}
                style={[
                  styles.modeButton,
                  currentMode === mode && styles.modeButtonActive,
                  { borderColor: colors.tint },
                  currentMode === mode && { backgroundColor: colors.tint },
                ]}
                onPress={() => setCurrentMode(mode)}
                disabled={sessionActive}>
                <ThemedText
                  style={[
                    styles.modeButtonText,
                    currentMode === mode && styles.modeButtonTextActive,
                  ]}>
                  {icon} {label}
                </ThemedText>
              </TouchableOpacity>
            ))}
          </View>
        </ThemedView>

        {/* Session Controls */}
        <ThemedView style={styles.section}>
          <View style={styles.buttonRow}>
            <TouchableOpacity
              style={[
                styles.actionButton,
                styles.startButton,
                (!connected || sessionActive) && styles.buttonDisabled,
              ]}
              onPress={handleStartSession}
              disabled={!connected || sessionActive}>
              <ThemedText style={styles.buttonText}>‚ñ∂Ô∏è Start Session</ThemedText>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.actionButton,
                styles.stopButton,
                !sessionActive && styles.buttonDisabled,
              ]}
              onPress={handleStopSession}
              disabled={!sessionActive}>
              <ThemedText style={styles.buttonText}>‚èπÔ∏è Stop Session</ThemedText>
            </TouchableOpacity>
          </View>
        </ThemedView>

        {/* Message Input */}
        <ThemedView style={styles.section}>
          <ThemedText type="subtitle" style={styles.sectionTitle}>
            üí¨ Send Message
          </ThemedText>
          <View style={styles.inputContainer}>
            <TextInput
              style={[
                styles.textInput,
                { color: colors.text, borderColor: colors.icon },
                !sessionActive && styles.inputDisabled,
              ]}
              placeholder="Type your message here..."
              placeholderTextColor={colors.icon}
              value={messageInput}
              onChangeText={setMessageInput}
              editable={sessionActive}
              multiline
              onSubmitEditing={handleSendMessage}
            />
            <TouchableOpacity
              style={[
                styles.sendButton,
                { backgroundColor: colors.tint },
                !sessionActive && styles.buttonDisabled,
              ]}
              onPress={handleSendMessage}
              disabled={!sessionActive}>
              <ThemedText style={styles.sendButtonText}>Send</ThemedText>
            </TouchableOpacity>
          </View>
        </ThemedView>

        {/* Response Area */}
        <ThemedView style={styles.section}>
          <ThemedText type="subtitle" style={styles.sectionTitle}>
            üìù Response
          </ThemedText>
          <ThemedView style={[styles.responseContainer, { borderColor: colors.icon }]}>
            <ScrollView style={styles.responseScroll}>
              <ThemedText style={styles.responseText}>
                {responseText || 'Waiting for response...'}
              </ThemedText>
            </ScrollView>
          </ThemedView>
        </ThemedView>
      </ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 20,
    paddingBottom: 40,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    opacity: 0.7,
    textAlign: 'center',
  },
  statusContainer: {
    padding: 16,
    borderRadius: 12,
    borderWidth: 2,
    marginBottom: 24,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 12,
  },
  modeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  modeButton: {
    flex: 1,
    minWidth: 100,
    padding: 12,
    borderRadius: 8,
    borderWidth: 2,
    alignItems: 'center',
  },
  modeButtonActive: {
    borderWidth: 2,
  },
  modeButtonText: {
    fontSize: 14,
    fontWeight: '600',
  },
  modeButtonTextActive: {
    color: '#fff',
  },
  buttonRow: {
    flexDirection: 'row',
    gap: 12,
  },
  actionButton: {
    flex: 1,
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  startButton: {
    backgroundColor: '#10b981',
  },
  stopButton: {
    backgroundColor: '#ef4444',
  },
  buttonDisabled: {
    opacity: 0.5,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  inputContainer: {
    flexDirection: 'row',
    gap: 12,
    alignItems: 'flex-end',
  },
  textInput: {
    flex: 1,
    minHeight: 50,
    maxHeight: 120,
    padding: 12,
    borderRadius: 8,
    borderWidth: 2,
    fontSize: 16,
    textAlignVertical: 'top',
  },
  inputDisabled: {
    opacity: 0.5,
  },
  sendButton: {
    paddingHorizontal: 24,
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sendButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  responseContainer: {
    minHeight: 200,
    maxHeight: 400,
    padding: 16,
    borderRadius: 12,
    borderWidth: 2,
  },
  responseScroll: {
    flex: 1,
  },
  responseText: {
    fontSize: 16,
    lineHeight: 24,
  },
});

```


Checking for linting errors and creating an environment configuration file:



Creating an environment configuration file and updating the README with setup instructions:


```shellscript
# Backend URL - Update this to match your Flask server
# For local development, use your computer's IP address instead of localhost
# Example: http://192.168.1.100:5001
EXPO_PUBLIC_BACKEND_URL=http://localhost:5001

```


Updating the README with setup instructions:


```markdown
# A-eye - Gemini Live API Mobile App üéôÔ∏è

A React Native/Expo mobile app frontend for the Gemini Live API Flask backend. This app provides real-time audio and video interaction with Google Gemini AI.

## Features

- üé• **Video Modes**: Camera, Screen capture, or None
- üéôÔ∏è **Real-time Audio**: Two-way audio communication with AI
- üí¨ **Text Messaging**: Send text messages to the AI assistant
- üì± **Cross-platform**: Works on iOS, Android, and Web
- üåì **Dark Mode**: Automatic light/dark theme support

## Prerequisites

1. **Flask Backend Running**: Make sure your Flask backend (`app.py`) is running on port 5001 (or configure a different port)
2. **Node.js**: Version 18 or higher
3. **Expo CLI**: Install globally with `npm install -g expo-cli`

## Setup

1. **Install dependencies**

   ```bash
   npm install
   ```

2. **Configure Backend URL**

   Create a `.env` file in the root directory (copy from `.env.example`):
   
   ```bash
   cp .env.example .env
   ```

   Update the `EXPO_PUBLIC_BACKEND_URL` in `.env`:
   - For **iOS Simulator**: Use `http://localhost:5001`
   - For **Android Emulator**: Use `http://10.0.2.2:5001`
   - For **Physical Device**: Use your computer's IP address (e.g., `http://192.168.1.100:5001`)

3. **Start the Flask Backend**

   In the root directory (where `app.py` is located):
   
   ```bash
   python app.py
   ```

4. **Start the Expo App**

   ```bash
   npx expo start
   ```

   In the output, you'll find options to open the app in a:
   - [development build](https://docs.expo.dev/develop/development-builds/introduction/)
   - [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
   - [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
   - [Expo Go](https://expo.dev/go) (limited functionality)

## Usage

1. **Connect**: The app will automatically connect to the Flask backend when started
2. **Select Mode**: Choose Camera, Screen, or None for video input
3. **Start Session**: Tap "Start Session" to begin the AI interaction
4. **Send Messages**: Type messages and tap "Send" to communicate with the AI
5. **View Responses**: AI text responses will appear in the Response area
6. **Stop Session**: Tap "Stop Session" when done

## Project Structure

- `app/` - Main app screens and routing
- `contexts/` - React contexts (Socket.IO connection)
- `components/` - Reusable UI components
- `.env` - Environment variables (backend URL configuration)

## Troubleshooting

### Connection Issues

- **"Disconnected" status**: 
  - Ensure Flask backend is running
  - Check that the backend URL in `.env` is correct
  - For physical devices, ensure your phone and computer are on the same network

### Socket.IO Connection

- The app uses Socket.IO for real-time communication
- Make sure CORS is enabled on the Flask backend (already configured in `app.py`)

## Learn more

- [Expo documentation](https://docs.expo.dev/)
- [React Native documentation](https://reactnative.dev/)
- [Socket.IO Client documentation](https://socket.io/docs/v4/client-api/)

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.

```


Verifying the implementation and checking for any missing dependencies:



Updating SocketContext to use expo-constants for environment variables:


```typescriptreact
import React, { createContext, useContext, useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';
import Constants from 'expo-constants';

type SessionMode = 'camera' | 'screen' | 'none';

interface SocketContextType {
  socket: Socket | null;
  connected: boolean;
  sessionActive: boolean;
  currentMode: SessionMode;
  responseText: string;
  statusMessage: string;
  statusType: 'connected' | 'disconnected' | 'info' | 'error';
  startSession: (mode: SessionMode) => void;
  stopSession: () => void;
  sendMessage: (text: string) => void;
  setCurrentMode: (mode: SessionMode) => void;
}

const SocketContext = createContext<SocketContextType | undefined>(undefined);

// Get backend URL from environment variable or Constants, with fallback
const getBackendUrl = () => {
  // Try process.env first (works in Expo SDK 49+)
  if (process.env.EXPO_PUBLIC_BACKEND_URL) {
    return process.env.EXPO_PUBLIC_BACKEND_URL;
  }
  // Try Constants.expoConfig.extra (for app.json config)
  if (Constants.expoConfig?.extra?.backendUrl) {
    return Constants.expoConfig.extra.backendUrl;
  }
  // Default fallback
  return 'http://localhost:5001';
};

const BACKEND_URL = getBackendUrl();

export function SocketProvider({ children }: { children: React.ReactNode }) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [connected, setConnected] = useState(false);
  const [sessionActive, setSessionActive] = useState(false);
  const [currentMode, setCurrentMode] = useState<SessionMode>('camera');
  const [responseText, setResponseText] = useState('');
  const [statusMessage, setStatusMessage] = useState('Disconnected');
  const [statusType, setStatusType] = useState<'connected' | 'disconnected' | 'info' | 'error'>('disconnected');

  useEffect(() => {
    // Initialize socket connection
    const newSocket = io(BACKEND_URL, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
    });

    // Connection events
    newSocket.on('connect', () => {
      setConnected(true);
      setStatusMessage('Connected to server');
      setStatusType('connected');
    });

    newSocket.on('disconnect', () => {
      setConnected(false);
      setSessionActive(false);
      setStatusMessage('Disconnected from server');
      setStatusType('disconnected');
    });

    newSocket.on('connected', (data: { status: string }) => {
      setStatusMessage(`Connected: ${data.status}`);
      setStatusType('connected');
    });

    // Session events
    newSocket.on('session_started', (data: { status: string; mode: SessionMode }) => {
      setSessionActive(true);
      setStatusMessage(`Session started in ${data.mode} mode`);
      setStatusType('info');
    });

    newSocket.on('session_stopped', (data: { status: string }) => {
      setSessionActive(false);
      setStatusMessage('Session stopped');
      setStatusType('disconnected');
      setResponseText('');
    });

    // Response events
    newSocket.on('text_response', (data: { text: string }) => {
      setResponseText((prev) => prev + data.text);
    });

    newSocket.on('audio_data', (data: { data: string }) => {
      // Audio data handling can be added here if needed
      console.log('Audio data received');
    });

    newSocket.on('info', (data: { message: string }) => {
      setStatusMessage(`Info: ${data.message}`);
      setStatusType('info');
    });

    newSocket.on('error', (data: { message: string }) => {
      const msg = data.message || '';
      // Don't show alerts for disabled features, just update status
      if (
        msg.includes('not available') ||
        msg.includes('disabled') ||
        msg.includes('PyAudio') ||
        msg.includes('Audio output') ||
        msg.includes('Audio input') ||
        msg.includes('Camera') ||
        msg.includes('Text-only')
      ) {
        setStatusMessage(`Info: ${msg}`);
        setStatusType('info');
      } else {
        setStatusMessage(`Error: ${msg}`);
        setStatusType('error');
      }
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, []);

  const startSession = (mode: SessionMode) => {
    if (socket && connected) {
      socket.emit('start_session', { mode });
      setCurrentMode(mode);
    }
  };

  const stopSession = () => {
    if (socket && sessionActive) {
      socket.emit('stop_session');
      setResponseText('');
    }
  };

  const sendMessage = (text: string) => {
    if (socket && sessionActive && text.trim()) {
      socket.emit('send_message', { text: text.trim() });
    }
  };

  return (
    <SocketContext.Provider
      value={{
        socket,
        connected,
        sessionActive,
        currentMode,
        responseText,
        statusMessage,
        statusType,
        startSession,
        stopSession,
        sendMessage,
        setCurrentMode,
      }}>
      {children}
    </SocketContext.Provider>
  );
}

export function useSocket() {
  const context = useContext(SocketContext);
  if (context === undefined) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}


```


Verifying the implementation is complete. Creating a quick setup guide:



## Summary

Frontend for the Flask backend is set up. Implemented:

### Completed tasks

1. Installed socket.io-client for React Native
2. Created Socket.IO context (`contexts/SocketContext.tsx`) for managing the connection
3. Built the main AI assistant screen (`app/(tabs)/index.tsx`) with:
   - Mode selection (Camera/Screen/None)
   - Start/Stop session controls
   - Message input and send functionality
   - Response display area
   - Status indicators
4. Updated root layout to include the SocketProvider
5. Added environment configuration (`.env.example`) and updated README

### Key features

- Real-time Socket.IO connection to Flask backend
- Session management (start/stop)
- Mode selection (camera, screen, none)
- Text messaging interface
- Response display
- Status indicators (connected/disconnected/info/error)
- Dark mode support (uses existing theme system)
- Responsive UI

### Next steps

1. Create `.env` file:
   ```bash
   cd A-eye
   cp .env.example .env
   ```
   Then update `EXPO_PUBLIC_BACKEND_URL` with your backend URL.

2. Start the Flask backend (in the root directory):
   ```bash
   python app.py
   ```

3. Start the Expo app:
   ```bash
   cd A-eye
   npx expo start
   ```

The app connects to your Flask backend and provides a mobile interface for the Gemini Live API. The UI matches the existing Expo app theme and supports light/dark modes.

```shellscript
   cd A-eye
   cp .env.example .env
```

```shellscript
   python app.py
```

```shellscript
   cd A-eye
   npx expo start
```

